// ==UserScript==
// @name         AI-Enhanced Evo Autohitter
// @namespace    http://tampermonkey.net/
// @version      3.4
// @author       baba yaga
// @match        https://evoworld.io/
// @icon         https://www.google.com/s2/favicons?sz=64&domain=evoworld.io
// @grant        none
// @description  AI-enhanced autohit maintaining fast-fight dominance while conquering slow fights
// ==/UserScript==

(function() {
    var flicking=false;

    const height={'grimReaper':156, 'pumpkinGhost':169, 'ghostlyReaper':165};

    const hitRangeX={'grimReaper':{'grimReaper':138 , 'pumpkinGhost':125,'ghostlyReaper':108},
                    'pumpkinGhost':{'grimReaper':161, 'pumpkinGhost':153, 'ghostlyReaper':108},
                    'ghostlyReaper':{'grimReaper':97, 'pumpkinGhost':87, 'ghostlyReaper':108}
    };

    const distAdjustmentY={'grimReaper':8, 'pumpkinGhost':3, 'ghostlyReaper':1};

    const hitBackRangeX={'grimReaper':{'grimReaper':134, 'pumpkinGhost':152, 'ghostlyReaper':144},
                    'pumpkinGhost':{'grimReaper':158, 'pumpkinGhost':148, 'ghostlyReaper':172},
                    'ghostlyReaper':{'grimReaper':134, 'pumpkinGhost':87, 'ghostlyReaper':105}
    };

    const reaperList = new Set(['grimReaper', 'pumpkinGhost', 'ghostlyReaper']);

    // ===== AI BATTLE INTELLIGENCE SYSTEM =====
    class BattleAI {
        constructor() {
            this.speedHistory = [];
            this.enemyBehaviorPattern = [];
            this.hitSuccessHistory = [];
            this.currentFightSpeed = 'fast';
            this.lastSpeedUpdate = Date.now();
            this.enemyFlickPattern = { frequency: 0, lastFlick: 0, isActive: false };
        }

        analyzeBattleContext(attacker, target) {
            const now = Date.now();
            
            // Calculate individual speeds for detailed analysis
            const mySpeed = Math.sqrt(attacker.moveSpeed.x ** 2 + attacker.moveSpeed.y ** 2);
            const enemySpeed = Math.sqrt(target.moveSpeed.x ** 2 + target.moveSpeed.y ** 2);
            const combinedSpeed = mySpeed + enemySpeed;
            
            // Enhanced speed tracking
            this.speedHistory.push({
                timestamp: now,
                speed: combinedSpeed,
                mySpeed: mySpeed,
                enemySpeed: enemySpeed
            });
            
            // Track enemy flicking behavior
            this.trackEnemyBehavior(target, now);
            
            // Keep relevant history
            this.speedHistory = this.speedHistory.filter(entry => now - entry.timestamp < 1500);
            this.enemyBehaviorPattern = this.enemyBehaviorPattern.filter(entry => now - entry.timestamp < 2000);
            
            // Update classification with AI logic
            if (now - this.lastSpeedUpdate > 150) { // More frequent updates
                this.updateIntelligentClassification();
                this.lastSpeedUpdate = now;
            }
            
            return this.generateBattleStrategy(mySpeed, enemySpeed);
        }

        trackEnemyBehavior(enemy, timestamp) {
            const behaviorEntry = {
                timestamp: timestamp,
                direction: enemy.direction,
                position: {x: enemy.position.x, y: enemy.position.y}
            };
            
            this.enemyBehaviorPattern.push(behaviorEntry);
            
            // Detect flicking patterns
            if (this.enemyBehaviorPattern.length >= 3) {
                const recent = this.enemyBehaviorPattern.slice(-3);
                let directionChanges = 0;
                
                for (let i = 1; i < recent.length; i++) {
                    if (recent[i].direction !== recent[i-1].direction) {
                        directionChanges++;
                    }
                }
                
                // Update flick pattern analysis
                if (directionChanges >= 1) {
                    this.enemyFlickPattern.frequency++;
                    this.enemyFlickPattern.lastFlick = timestamp;
                    this.enemyFlickPattern.isActive = true;
                } else if (timestamp - this.enemyFlickPattern.lastFlick > 1000) {
                    this.enemyFlickPattern.isActive = false;
                }
            }
        }

        updateIntelligentClassification() {
            if (this.speedHistory.length === 0) return;
            
            const avgSpeed = this.speedHistory.reduce((sum, entry) => sum + entry.speed, 0) / this.speedHistory.length;
            const avgMySpeed = this.speedHistory.reduce((sum, entry) => sum + entry.mySpeed, 0) / this.speedHistory.length;
            const avgEnemySpeed = this.speedHistory.reduce((sum, entry) => sum + entry.enemySpeed, 0) / this.speedHistory.length;
            
            // AI-enhanced classification considers multiple factors
            const speedVariation = this.calculateSpeedVariation();
            const isStableMovement = speedVariation < 20;
            
            // Multi-factor classification
            if (avgSpeed > 120 || (avgMySpeed > 80 && avgEnemySpeed > 40)) {
                this.currentFightSpeed = 'fast';
            } else if (avgSpeed > 40 && isStableMovement) {
                this.currentFightSpeed = 'medium';
            } else if (avgSpeed <= 40 && this.enemyFlickPattern.isActive) {
                this.currentFightSpeed = 'slow-flick'; // Special category for slow + flicking
            } else {
                this.currentFightSpeed = 'slow';
            }
        }

        calculateSpeedVariation() {
            if (this.speedHistory.length < 3) return 0;
            
            const speeds = this.speedHistory.map(entry => entry.speed);
            const avg = speeds.reduce((sum, speed) => sum + speed, 0) / speeds.length;
            const variance = speeds.reduce((sum, speed) => sum + Math.pow(speed - avg, 2), 0) / speeds.length;
            return Math.sqrt(variance);
        }

        generateBattleStrategy(mySpeed, enemySpeed) {
            const context = {
                fightType: this.currentFightSpeed,
                mySpeed: mySpeed,
                enemySpeed: enemySpeed,
                enemyFlicking: this.enemyFlickPattern.isActive,
                speedDifference: mySpeed - enemySpeed
            };

            // AI decision matrix
            let timing, buffer, flickAdjust, frontAdjust;

            switch (this.currentFightSpeed) {
                case 'fast':
                    // PRESERVE YOUR WINNING FORMULA
                    timing = 60;
                    buffer = 5;
                    flickAdjust = -20;
                    frontAdjust = -3;
                    break;

                case 'medium':
                    // Balanced approach
                    timing = mySpeed > 60 ? 70 : 80;
                    buffer = 3;
                    flickAdjust = mySpeed > 50 ? -22 : -23;
                    frontAdjust = mySpeed > 50 ? -2 : -3;
                    break;

                case 'slow-flick':
                    // Special handling for slow fights with flicking enemy
                    timing = 110; // Much more conservative
                    buffer = 0; // No buffer to prevent early hits
                    flickAdjust = -30; // Very conservative flick
                    frontAdjust = -8; // Conservative front hit
                    break;

                case 'slow':
                    // Enhanced slow fight strategy
                    timing = this.enemyFlickPattern.isActive ? 105 : 100;
                    buffer = 1;
                    flickAdjust = -26;
                    frontAdjust = context.speedDifference > 20 ? -1 : -1; // Minimal adjustment if I'm faster
                    break;

                default:
                    timing = 80;
                    buffer = 3;
                    flickAdjust = -23;
                    frontAdjust = -3;
            }

            // AI micro-adjustments based on context
            if (context.speedDifference > 30) {
                timing -= 5; // I'm much faster
                flickAdjust += 3; // Less conservative
            } else if (context.speedDifference < -30) {
                timing += 8; // Enemy much faster
                flickAdjust -= 3; // More conservative
            }

            // Flick frequency adjustment
            if (this.enemyFlickPattern.frequency > 5 && this.currentFightSpeed !== 'fast') {
                timing += 5; // Extra caution for frequent flickers
                buffer = Math.max(0, buffer - 1);
            }

            return {
                timing: Math.max(50, Math.min(120, timing)),
                buffer: Math.max(0, buffer),
                flickAdjust: flickAdjust,
                frontAdjust: frontAdjust,
                fightType: this.currentFightSpeed,
                context: context
            };
        }

        getOptimalTiming() {
            const strategy = this.generateBattleStrategy(0, 0);
            return strategy.timing;
        }

        getDetectionBuffer() {
            const strategy = this.generateBattleStrategy(0, 0);
            return strategy.buffer;
        }

        getFlickAdjustment() {
            const strategy = this.generateBattleStrategy(0, 0);
            return strategy.flickAdjust;
        }

        getFrontAdjustment() {
            const strategy = this.generateBattleStrategy(0, 0);
            return strategy.frontAdjust;
        }
    }

    const battleAI = new BattleAI();

    // ===== AI-ENHANCED RANGE FUNCTIONS =====
    function isWithinXRange(attacker, target, range, distAdjustment = 0) {
        var x1 = attacker.position.x;
        var x2 = target.position.x;
        var relativeSpeed = Math.abs(attacker.moveSpeed.x - target.moveSpeed.x);
        
        // Get AI strategy
        const strategy = battleAI.analyzeBattleContext(attacker, target);
        
        const frameTime = Math.max(16, 700 / (lastFps || 60));
        const serverDelay = Math.max(10, latency * 0.8);
        
        // AI-adjusted prediction based on fight type
        let predictionFactor;
        if (strategy.fightType === 'fast') {
            predictionFactor = 1.0; // Keep your winning formula
        } else if (strategy.fightType === 'slow-flick') {
            predictionFactor = 0.3; // Very conservative for slow+flick
        } else if (strategy.fightType === 'slow') {
            predictionFactor = 0.5; // Conservative for slow
        } else {
            predictionFactor = 0.8; // Medium fights
        }
        
        const totalDelay = (frameTime + serverDelay) * predictionFactor;
        var predictedDistance = Math.abs(x2-x1) - (totalDelay * relativeSpeed / 1000) + distAdjustment;
        
        return predictedDistance <= (range[attacker.name][target.name] + strategy.buffer);
    }

    function isWithinYRange(attacker, target, heights, distAdjustment = 0) {
        var y1 = attacker.position.y;
        var y2 = target.position.y;
        var relativeSpeed = Math.abs(attacker.moveSpeed.y - target.moveSpeed.y);
        
        const strategy = battleAI.analyzeBattleContext(attacker, target);
        
        const frameTime = Math.max(16, 700 / (lastFps || 60));
        const serverDelay = Math.max(10, latency * 0.8);
        
        let predictionFactor;
        if (strategy.fightType === 'fast') {
            predictionFactor = 1.0;
        } else if (strategy.fightType === 'slow-flick') {
            predictionFactor = 0.3;
        } else if (strategy.fightType === 'slow') {
            predictionFactor = 0.5;
        } else {
            predictionFactor = 0.8;
        }
        
        const totalDelay = (frameTime + serverDelay) * predictionFactor;
        var predictedDistance = Math.abs(y2-y1) - (totalDelay * relativeSpeed / 1000) + distAdjustment;
        
        let hitRangeY;
        if (y1>y2){
            hitRangeY=heights[target.name];
        } else {
            hitRangeY=heights[attacker.name];
        }
        
        return predictedDistance <= (hitRangeY + Math.max(0, Math.floor(strategy.buffer * 0.7)));
    }

    // ===== AI-POWERED AUTO HIT =====
    function autoHit(){
        let enemy = getClosestReaper();
        if (typeof enemy != 'object' || typeof game.me != 'object' || !reaperList.has(game.me.name)){
            return;
        }

        // Get AI battle strategy
        const strategy = battleAI.analyzeBattleContext(game.me, enemy);
        
        // Debug output (minimal)
        if (Math.random() < 0.005) {
            console.log(`AI: ${strategy.fightType}, Timing: ${strategy.timing}ms, My: ${strategy.context.mySpeed.toFixed(0)}, Enemy: ${strategy.context.enemySpeed.toFixed(0)}`);
        }

        let onLeftSide = (game.me.position.x <= enemy.position.x);
        let enemyFlicking = (onLeftSide && enemy.direction === 1) || (!onLeftSide && enemy.direction === -1);
        let facingEnemy = (onLeftSide && game.me.direction === 1) || (!onLeftSide && game.me.direction === -1);

        if (!flicking){
            facingEnemy = true;
        }

        // AI-driven combat execution
        if (facingEnemy){
            if (enemyFlicking){
                if (isWithinXRange(game.me, enemy, hitBackRangeX) && isWithinYRange(game.me, enemy, height)){
                    skillUse();
                    setTimeout(skillStop, strategy.timing);
                }
            } else {
                if (isWithinXRange(game.me, enemy, hitRangeX) && isWithinYRange(game.me, enemy, height)){
                    skillUse();
                    setTimeout(skillStop, strategy.timing);
                }
            }
        } else {
            if (enemyFlicking){
                if (isWithinXRange(game.me, enemy, hitBackRangeX, strategy.flickAdjust) && isWithinYRange(game.me, enemy, height)){
                    if (onLeftSide){
                        simulateQuickRightArrowKeyWithDelay();
                        skillUse();
                        setTimeout(skillStop, strategy.timing);
                    } else {
                        simulateQuickLeftArrowKeyWithDelay();
                        skillUse();
                        setTimeout(skillStop, strategy.timing);
                    }
                }
            } else {
                if (isWithinXRange(game.me, enemy, hitRangeX, strategy.frontAdjust) && isWithinYRange(game.me, enemy, height)){
                    if (onLeftSide){
                        simulateQuickRightArrowKeyWithDelay();
                        skillUse();
                        setTimeout(skillStop, strategy.timing);
                    } else {
                        simulateQuickLeftArrowKeyWithDelay();
                        skillUse();
                        setTimeout(skillStop, strategy.timing);
                    }
                }
            }
        }
    }

    // ===== ORIGINAL FUNCTIONS (UNCHANGED) =====
    function simulateQuickRightArrowKeyWithDelay() {
        const keyDownEvent = new KeyboardEvent('keydown', {
            key: 'ArrowRight', code: 'ArrowRight', keyCode: 39, which: 39, bubbles: true, cancelable: true
        });
        document.dispatchEvent(keyDownEvent);

        setTimeout(() => {
            const keyUpEvent = new KeyboardEvent('keyup', {
                key: 'ArrowRight', code: 'ArrowRight', keyCode: 39, which: 39, bubbles: true, cancelable: true
            });
            document.dispatchEvent(keyUpEvent);
        }, 150);
    }

    function simulateQuickLeftArrowKeyWithDelay() {
        const keyDownEvent = new KeyboardEvent('keydown', {
            key: 'ArrowLeft', code: 'ArrowLeft', keyCode: 37, which: 37, bubbles: true, cancelable: true
        });
        document.dispatchEvent(keyDownEvent);

        setTimeout(() => {
            const keyUpEvent = new KeyboardEvent('keyup', {
                key: 'ArrowLeft', code: 'ArrowLeft', keyCode: 37, which: 37, bubbles: true, cancelable: true
            });
            document.dispatchEvent(keyUpEvent);
        }, 150);
    }

    function getMagnitude(objPos) {
        var myPos = game.me.position;
        var xDifference = Math.abs(myPos.x - objPos.x);
        var yDifference = Math.abs(myPos.y - objPos.y);
        return xDifference + yDifference;
    }

    function getClosestReaper() {
        if (gameServer == 'undefined' || game.me == 'undefined' || imDead || !joinedGame) {
            return;
        }

        let list = game.sortToDraw(game.hashMap.retrieveVisibleByClient(game));
        let reaperInVision = [];
        for(let i=0; i < list.length; i++) {
            var curEntity = list[i];
            if (curEntity.hp != null && curEntity.deleted == false) {
                if (curEntity.level != null) {
                    if (reaperList.has(curEntity.name) && curEntity !== game.me) {
                        reaperInVision.push(curEntity);
                    }
                }
            }
        }

        var closestReaper = undefined;
        var closestMagn = undefined;
        for(var i = 0; i < reaperInVision.length; i++) {
            var curEntry = reaperInVision[i];
            var checkingMagn = getMagnitude(curEntry.position);
            
            if (closestReaper === undefined || checkingMagn < closestMagn) {
                closestReaper = curEntry;
                closestMagn = checkingMagn;
            }
        }
        return closestReaper;
    }

    // ===== EVENT HANDLERS =====
    var autoHitting = false;
    document.addEventListener("keyup", (event) => {
        if (event.keyCode === 82) {
            autoHitting = !autoHitting;
            textMsg(autoHitting ? "AI-Enhanced Autohitting" : "AI Autohitting OFF", 
                   autoHitting ? '#00FF00' : '#FF0000', 5000);
        } else if (event.keyCode === 73) {
            const enemy = getClosestReaper();
            if (enemy) {
                const strategy = battleAI.analyzeBattleContext(game.me, enemy);
                console.log("=== AI DEBUG ===");
                console.log("Fight Type:", strategy.fightType);
                console.log("My Speed:", strategy.context.mySpeed.toFixed(1));
                console.log("Enemy Speed:", strategy.context.enemySpeed.toFixed(1));
                console.log("Enemy Flicking:", strategy.context.enemyFlicking);
                console.log("AI Timing:", strategy.timing + "ms");
                console.log("Distance:", Math.abs(game.me.position.x - enemy.position.x));
            }
        } else if (event.keyCode === 32) {
            skillStop();
        } else if (event.keyCode === 17) {
            flicking = !flicking;
            textMsg(flicking ? "AI-Enhanced Flicking" : "AI Flicking OFF", 
                   flicking ? '#00FF00' : '#FF0000', 5000);
        }
    });

    function initialize() {
        gameServer['on']('disconnect', function() {
            gameServer = 'undefined';
            waitForServer();
        });

        if (typeof gameServer.on === 'function') {
            gameServer['on'](socketMsgType.SYNC, function(data) {
                if (autoHitting) autoHit();
            });
            
            if (socketMsgType.PLAYER_UPDATE) {
                gameServer['on'](socketMsgType.PLAYER_UPDATE, function(data) {
                    if (autoHitting) autoHit();
                });
            }
            
            function continuousDetection() {
                if (autoHitting && typeof gameServer !== 'undefined' && joinedGame && !imDead) {
                    autoHit();
                }
                requestAnimationFrame(continuousDetection);
            }
            continuousDetection();
            
        } else {
            console.error('gameServerOn is not a function');
        }
    }

    function waitForServer() {
        if (typeof gameServer == 'undefined' || typeof gameServer['on'] == 'undefined') {
            setTimeout(waitForServer, 500);
        } else {
            initialize();
        }
    }

    waitForServer();
})();

function bonus() {
    startBonus = true;
 }
setInterval(bonus, 0);

function echolocation() {
    visionType = 1;
}
setInterval(echolocation,0);

(function() {
    'use strict';
    var flyUp = false;
    addEventListener("keydown", (event) => {
        if (event.keyCode == 69) {
            if (flyUp === false) {
                const curTime = Date.now();
                flyUp = curTime;
                boost();
                const loop = setInterval(() => {
                    if (flyUp === curTime) {
                        boost();
                    } else {
                        clearInterval(loop);
                    }
                }, 45);
            }
        }
    });
    
    addEventListener("keyup", (event) => {
        if (event.keyCode == 69) flyUp = false;
    });
})();
